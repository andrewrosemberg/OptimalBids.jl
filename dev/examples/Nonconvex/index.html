<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonconvex.jl · OptimalBids.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://andrewrosemberg.github.io/OptimalBids.jl/examples/Nonconvex/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OptimalBids.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Nonconvex.jl</a><ul class="internal"><li><a class="tocitem" href="#using-Nonconvex.jl"><span>using Nonconvex.jl</span></a></li></ul></li><li><a class="tocitem" href="../Optim/">Optim.jl</a></li><li><a class="tocitem" href="../GaussianProcesses/">AbstractGPs.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Nonconvex.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonconvex.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andrewrosemberg/OptimalBids.jl/blob/master/docs/src/examples/Nonconvex.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Profit-Maximization-Example"><a class="docs-heading-anchor" href="#Profit-Maximization-Example">Profit Maximization Example</a><a id="Profit-Maximization-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Profit-Maximization-Example" title="Permalink"></a></h1><h2 id="using-Nonconvex.jl"><a class="docs-heading-anchor" href="#using-Nonconvex.jl">using Nonconvex.jl</a><a id="using-Nonconvex.jl-1"></a><a class="docs-heading-anchor-permalink" href="#using-Nonconvex.jl" title="Permalink"></a></h2><p>This a example on how to use <a href="https://github.com/JuliaNonconvex/Nonconvex.jl">Nonconvex.jl</a> to maximize the profit of a company operating in a defined market (through the <code>OptimalBids</code> API).</p><ul><li>For this example, we will use a market of type <code>PowerModelsMarkets</code> which represents an energy spot market.</li><li>Case instance is IEEE 118 Bus Case</li><li>To ilustrate a situation where the company defines the distribution of volume across it&#39;s assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.  </li></ul><h3 id="Include-Needed-Packages"><a class="docs-heading-anchor" href="#Include-Needed-Packages">Include Needed Packages</a><a id="Include-Needed-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Include-Needed-Packages" title="Permalink"></a></h3><pre><code class="language- hljs">using OptimalBids
using OptimalBids.PowerModelsMarkets
using Clp # Market Clearing Solver
using JuMP: optimizer_with_attributes

using Nonconvex
using NonconvexIpopt # Nonconvex.@load Ipopt
using NonconvexBayesian # Nonconvex.@load BayesOpt
using Zygote

using AbstractGPs
using KernelFunctions

using Plots # For some evaluation plots at the end
using Plots.PlotMeasures
using Downloads # To download Test Cases
</code></pre><h3 id="Case-Definition"><a class="docs-heading-anchor" href="#Case-Definition">Case Definition</a><a id="Case-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Definition" title="Permalink"></a></h3><pre><code class="language- hljs">
# Read market data from IEEE 118 bus case
case_name = &quot;pglib_opf_case118_ieee.m&quot;
DATA_DIR = mktempdir()
case_file_path = joinpath(DATA_DIR, case_name)
Downloads.download(&quot;https://raw.githubusercontent.com/power-grid-lib/pglib-opf/01681386d084d8bd03b429abcd1ee6966f68b9a3/&quot; * case_name, case_file_path)
network_data = PowerModels.parse_file(case_file_path)

# Measure maximum load
max_load = sum(load[&quot;pd&quot;] for load in values(network_data[&quot;load&quot;])) * network_data[&quot;baseMVA&quot;]

# Pretend we are a company constructing a new set of generators in the grid.
# Choose a percentage of the total number of buses to install the new generators:
percentage_buses = 0.09

# We need the keys PowerModels uses to reference the appropriate buses in it&#39;s network data dictionary.
# First, find out all available keys:
bus_indexes = collect(keys(network_data[&quot;bus&quot;]))
# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):
num_buses = length(bus_indexes)
num_strategic_buses = ceil(Int, percentage_buses * num_buses)
# To avoid any biases let&#39;s grab some generators in the middle:
bus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]
# Finally, add new generators to the network grid data and collect their reference keys.
generator_indexes = [
    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes
]
</code></pre><h3 id="OptimalBids-API"><a class="docs-heading-anchor" href="#OptimalBids-API">OptimalBids API</a><a id="OptimalBids-API-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalBids-API" title="Permalink"></a></h3><pre><code class="language- hljs">
# Define market
market = build_market(
    PowerModelsMarket,
    network_data,
    generator_indexes,
    optimizer_with_attributes(Clp.Optimizer, &quot;LogLevel&quot; =&gt; 0),
)

# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.
using Random
rng = MersenneTwister(666)
offer_weights = rand(rng, num_strategic_buses)
offer_weights = offer_weights / sum(offer_weights)

# However, the decision maker is allowed to increase all bids evenly:
min_total_volume = 0.0
max_total_volume = 155.0
range_mul_factor = min_total_volume:1.0:max_total_volume
bid_range = [offer_weights .* [i] for i in range_mul_factor]
p_curve = profit_curve!(market, bid_range)
maximum_pq_curve, argmax_pq_curve = findmax(p_curve)

# Mesure time to change bids and solve opf
num_opfs = 10
opf_time = @elapsed [profit_for_bid!(market, offer_weights) for _ = 1:num_opfs]
opf_time /= num_opfs

# Let&#39;s plot and see how the range profit evaluatiuon went:
plt_range = plot(collect(range_mul_factor) * 100 / max_load, p_curve,
    label=&quot;Range Evaluation&quot;,
    ylabel=&quot;Profit (USD)&quot;,
    xlabel=&quot;Bid Volume (% Market Share)&quot;,
    legend=:outertopright,
    left_margin=10mm,
    bottom_margin=10mm,
    size=(900, 600),
    color=:black,
    width=2.0
);
plt_comp = deepcopy(plt_range);</code></pre><h3 id="Nonconvex-API"><a class="docs-heading-anchor" href="#Nonconvex-API">Nonconvex API</a><a id="Nonconvex-API-1"></a><a class="docs-heading-anchor-permalink" href="#Nonconvex-API" title="Permalink"></a></h3><pre><code class="language- hljs">
# Nonconvex needs a minimization objective function that only receives the decision vector.
function profit_function(total_volume)
    return - profit_for_bid!(market, offer_weights .* first(total_volume))
end

mutable struct StorageCallbackProfit &lt;: Function
    start_time::Float64
    fcalls::Int
    visited_objective::Array{Float64}
    visited_volumes::Array{Float64}
    visited_times::Array{Float64}
    projection::Array{Float64}
end
StorageCallbackProfit(maxiter, start_time; projection=offer_weights) = StorageCallbackProfit(start_time, 0, 
    Array{Float64}(undef, 5 * maxiter),
    Array{Float64}(undef, 5 * maxiter),
    Array{Float64}(undef, 5 * maxiter),
    projection
)

function (callback::StorageCallbackProfit)(total_volume)
    Zygote.@ignore callback.fcalls += 1
    Zygote.@ignore callback.visited_volumes[callback.fcalls] = sum(callback.projection .* total_volume)
    Zygote.@ignore callback.visited_times[callback.fcalls] = time() - callback.start_time
    obj = profit_for_bid!(market, callback.projection .* total_volume)
    Zygote.@ignore callback.visited_objective[callback.fcalls] = obj
    return - obj
end
</code></pre><h3 id="Motivation-for-fixed-weights"><a class="docs-heading-anchor" href="#Motivation-for-fixed-weights">Motivation for fixed weights</a><a id="Motivation-for-fixed-weights-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation-for-fixed-weights" title="Permalink"></a></h3><h4 id="Random-bids-range-evaluation"><a class="docs-heading-anchor" href="#Random-bids-range-evaluation">Random bids range evaluation</a><a id="Random-bids-range-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-bids-range-evaluation" title="Permalink"></a></h4><pre><code class="language- hljs">
number_of_curves = 30
p_curves = Array{Any}(undef, number_of_curves)

min_total_volume = 0.0
max_total_volume = 655.0
range_mul_factor = min_total_volume:5.0:max_total_volume

num_points = length(range_mul_factor)

for i = 1:2
    offer_weights = rand(rng, num_strategic_buses)
    offer_weights = offer_weights / sum(offer_weights)

    # However, the decision maker is allowed to increase all bids evenly:
    bid_range = [offer_weights .* [j] for j in range_mul_factor]
    p_curves[i] = profit_curve!(market, bid_range)
end

for i = 3:number_of_curves
    mul_factor = rand(rng, max_total_volume/4:max_total_volume)
    offer_weights_up = rand(rng, num_strategic_buses)
    offer_weights_up = offer_weights_up / sum(offer_weights_up) * mul_factor
    offer_weights_down = rand(rng, num_strategic_buses)
    offer_weights_down = offer_weights_down / sum(offer_weights_down) * mul_factor
    norm(offer_weights_up - offer_weights_down, 1)
    direction = offer_weights_up - offer_weights_down

    # However, the decision maker is allowed to increase all bids evenly:
    bid_range = [offer_weights_down + direction * i for i in range(0,1, num_points)]
    p_curves[i] = profit_curve!(market, bid_range)
end

plot(range(-100,100, num_points), p_curves,
    label=&quot;Range Evaluation&quot;,
    ylabel=&quot;Profit (USD)&quot;,
    xlabel=&quot;Relative Distance (%)&quot;,
    legend=false,
    left_margin=10mm,
    bottom_margin=10mm,
    size=(900, 600)
)</code></pre><h4 id="Individual-bids"><a class="docs-heading-anchor" href="#Individual-bids">Individual bids</a><a id="Individual-bids-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-bids" title="Permalink"></a></h4><pre><code class="language- hljs">
min_total_volume = 0.0
max_total_volume = 155.0
range_mul_factor = min_total_volume:1.0:max_total_volume

plt_comp_individual = plot(collect(range_mul_factor) * 100 / max_load, p_curve,
    label=&quot;Regularized Benchmark&quot;,
    ylabel=&quot;Profit (USD)&quot;,
    xlabel=&quot;Bid Volume (% Market Share)&quot;,
    legend=:outertopright,
    left_margin=10mm,
    bottom_margin=10mm,
    size=(900, 600),
    color=:black,
    width=2.0
);

for i = 1:num_strategic_buses
    ind_offer = zeros(num_strategic_buses)
    ind_offer[i] = 1.0
    bid_range_individual = [ind_offer .* [i] for i in range_mul_factor]
    p_curve_individual = profit_curve!(market, bid_range_individual)
    plot!(plt_comp_individual, collect(range_mul_factor) * 100 / max_load, p_curve_individual, label=&quot;Node $i&quot;)
end

plot(plt_comp_individual)</code></pre><h4 id="Unconstrained-bids"><a class="docs-heading-anchor" href="#Unconstrained-bids">Unconstrained bids</a><a id="Unconstrained-bids-1"></a><a class="docs-heading-anchor-permalink" href="#Unconstrained-bids" title="Permalink"></a></h4><pre><code class="language- hljs">
# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).
# ps.: Currently, no option for limiting fcalls.
maxiter = 60

storage_profit_function = StorageCallbackProfit(maxiter * 10, time(); projection=ones(num_strategic_buses))

# Build Nonconvex optimization model:
model = Nonconvex.Model()
set_objective!(model, storage_profit_function, flags = [:expensive])
addvar!(model, fill(min_total_volume, num_strategic_buses), fill(max_total_volume * 2, num_strategic_buses))
add_ineq_constraint!(model, x -&gt; sum(x) - max_total_volume * 8)

# Solution Method: Bayesian Optimization
alg = BayesOptAlg(IpoptAlg())
options = BayesOptOptions(
    sub_options = IpoptOptions(max_iter = 20, print_level = 0),
    ninit=3,
    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5, initialize=true, postoptimize=false,
    kernel= RationalKernel(α=2.27e8) ∘ ScaleTransform(0.01),
    noise=0.001,
    std_multiple=8.67e4,
    fit_prior=false # not working with custom priors
)

# Optimize model:
r_bayes = optimize(model, alg, offer_weights * 5; options = options)

best_solution = r_bayes.minimizer
best_profit = -r_bayes.minimum

plt_comp_individual = plot(collect(range_mul_factor) * 100 / max_load, p_curve,
    label=&quot;Regularized Benchmark&quot;,
    ylabel=&quot;Profit (USD)&quot;,
    xlabel=&quot;Bid Volume (% Market Share)&quot;,
    legend=:outertopright,
    left_margin=10mm,
    bottom_margin=10mm,
    size=(900, 600),
    color=:black,
    width=2.0
);

scatter!(plt_comp_individual, [sum(best_solution)] * 100 / max_load, [best_profit],
    label=&quot;Multinode BayesOpt - OPF Calls:$(storage_profit_function.fcalls)&quot;,
)

plt_surrogate = deepcopy(plt_comp_individual);

range_mul_factor_multi_node = min_total_volume:1.0:max_load
bid_range = [best_solution .* [i / sum(best_solution)] for i in range_mul_factor_multi_node]
p_curve_multi_node = profit_curve!(market, bid_range)

plot!(plt_surrogate, collect(range_mul_factor_multi_node) * 100 / max_load, p_curve_multi_node; 
    label=&quot;Multi Node Range Evaluation&quot;,
    color=&quot;orange&quot;
);

scatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, 
    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=&quot;Visited&quot;,
    color=&quot;orange&quot;
)</code></pre><pre><code class="language- hljs">storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time

plot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], 
(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,
    xlabel=&quot;Time (x OPF)&quot;,
    ylabel=&quot;Optimality Gap (%)&quot;,
    ylim=(0.0,1.0),
    legend=false
)</code></pre><h3 id="BayesOpt-(0-Order)"><a class="docs-heading-anchor" href="#BayesOpt-(0-Order)">BayesOpt (0-Order)</a><a id="BayesOpt-(0-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#BayesOpt-(0-Order)" title="Permalink"></a></h3><pre><code class="language- hljs">
# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).
# ps.: Currently, no option for limiting fcalls.
maxiter = 10

storage_profit_function = StorageCallbackProfit(maxiter * 10, time())

# Build Nonconvex optimization model:
model = Nonconvex.Model()
set_objective!(model, storage_profit_function, flags = [:expensive])
addvar!(model, [min_total_volume], [max_total_volume])
add_ineq_constraint!(model, x -&gt; sum(x) - max_total_volume)

# Solution Method: Bayesian Optimization
alg = BayesOptAlg(IpoptAlg())
options = BayesOptOptions(
    sub_options = IpoptOptions(max_iter = 20, print_level = 0),
    # ninit=Int(floor(maxiter / 5)),
    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5, initialize=true, postoptimize=false,
    kernel= RationalKernel(α=2.27e8) ∘ ScaleTransform(0.01),
    noise=0.001,
    std_multiple=8.67e4,
    fit_prior=false # not working with custom priors
)

# Optimize model:
r_bayes = optimize(model, alg, [max_total_volume / 2]; options = options)

best_solution = r_bayes.minimizer
best_profit = -r_bayes.minimum

scatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],
    label=&quot;BayesOpt - OPF Calls:$(storage_profit_function.fcalls)&quot;,
)

plt_surrogate = deepcopy(plt_range);

up_surrugate = -getproperty.(r_bayes.surrogates[1].(range_mul_factor), :lo)
lb_surrugate = -getproperty.(r_bayes.surrogates[1].(range_mul_factor), :hi)
std_surrugate = (up_surrugate .- lb_surrugate) / 2
med_surrugate = lb_surrugate + std_surrugate

storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time

plot!(plt_surrogate, range_mul_factor * 100 / max_load, med_surrugate,
    ribbon=std_surrugate,
    title=&quot;BayesOpt Analysis&quot;,
    label=&quot;Surrogate Function&quot;,
);
scatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, 
    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=&quot;Visited&quot;
)</code></pre><pre><code class="language- hljs">
plot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], 
(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,
    xlabel=&quot;Time (x OPF)&quot;,
    ylabel=&quot;Optimality Gap (%)&quot;,
    ylim=(0.0,1.0),
    legend=false
)</code></pre><h3 id="NLopt-BOBYQA-(0-Order)"><a class="docs-heading-anchor" href="#NLopt-BOBYQA-(0-Order)">NLopt - BOBYQA (0-Order)</a><a id="NLopt-BOBYQA-(0-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#NLopt-BOBYQA-(0-Order)" title="Permalink"></a></h3><pre><code class="language- hljs">
using NonconvexNLopt

maxeval = 50
storage_profit_function = StorageCallbackProfit(maxeval * 10, time())

# Build Nonconvex optimization model:
model = Nonconvex.Model()
set_objective!(model, storage_profit_function)
addvar!(model, [min_total_volume], [max_total_volume])

# Solution Method: Sequential Least-Squares Quadratic Programming
method = :LN_BOBYQA
alg = NLoptAlg(:LN_BOBYQA)
options = NLoptOptions(maxeval=maxeval)

# Optimize model
r = optimize(model, alg, [min_total_volume]; options = options)

best_solution = r.minimizer
best_profit = -r.minimum

scatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],
    label=&quot;NLOpt-$(method) - OPF Calls:$(storage_profit_function.fcalls)&quot;,
);


plt_surrogate = deepcopy(plt_range);

storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time

scatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, 
    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=&quot;Visited&quot;,
    title=&quot;BOBYQA&quot;
)

plot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], 
(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,
    xlabel=&quot;Time (x OPF)&quot;,
    ylabel=&quot;Optimality Gap (%)&quot;,
    ylim=(0.0,1.0),
    legend=false,
    title=&quot;BOBYQA&quot;
)</code></pre><h3 id="NonconvexMultistart-GPSampler-(0-Order)"><a class="docs-heading-anchor" href="#NonconvexMultistart-GPSampler-(0-Order)">NonconvexMultistart - GPSampler (0-Order)</a><a id="NonconvexMultistart-GPSampler-(0-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#NonconvexMultistart-GPSampler-(0-Order)" title="Permalink"></a></h3><pre><code class="language- hljs">
using NonconvexMultistart

maxiter = 10
storage_profit_function = StorageCallbackProfit(maxiter * 10, time())

# Build Nonconvex optimization model:
model = Nonconvex.Model()
set_objective!(model, storage_profit_function)
addvar!(model, [min_total_volume], [max_total_volume])

# Solution Method: Hyperopt
method = :Hyperopt
alg = HyperoptAlg(IpoptAlg())
options = HyperoptOptions(
    sub_options = IpoptOptions(max_iter = maxiter), sampler = GPSampler(),
    iters = 2,
    keep_all=true
)

# Optimize model
r_hyp = optimize(model, alg, [max_total_volume / 2], options = options)

best_solution = r_hyp.minimizer
best_profit = -r_hyp.minimum

scatter!(plt_comp, best_solution * 100 / max_load, [best_profit],
    label=&quot;$(method) Offer - OPF Calls:$(storage_profit_function.fcalls)&quot;,
);

plt_visited = deepcopy(plt_range)

storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time

scatter!(plt_visited, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, 
    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=&quot;Visited&quot;
)

plot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], 
(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,
    xlabel=&quot;Time (x OPF)&quot;,
    ylabel=&quot;Optimality Gap (%)&quot;,
    ylim=(0.0,1.0),
    legend=false
)</code></pre><h3 id="Profit-Comparison-NLP-0-Order-Strategies"><a class="docs-heading-anchor" href="#Profit-Comparison-NLP-0-Order-Strategies">Profit Comparison NLP 0-Order Strategies</a><a id="Profit-Comparison-NLP-0-Order-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Profit-Comparison-NLP-0-Order-Strategies" title="Permalink"></a></h3><pre><code class="language- hljs">
plot(plt_comp, margin=5Plots.mm,
    title=&quot;Profit Comparison NLP Strategies&quot;,
)</code></pre><h3 id="NLopt-CCSAQ-(1-Order)"><a class="docs-heading-anchor" href="#NLopt-CCSAQ-(1-Order)">NLopt - CCSAQ (1-Order)</a><a id="NLopt-CCSAQ-(1-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#NLopt-CCSAQ-(1-Order)" title="Permalink"></a></h3><pre><code class="language- hljs">
using NonconvexNLopt

maxeval = 50
storage_profit_function = StorageCallbackProfit(maxeval * 10, time())

# Build Nonconvex optimization model:
model = Nonconvex.Model()
set_objective!(model, storage_profit_function)
addvar!(model, [min_total_volume], [max_total_volume])

# Solution Method: Sequential Least-Squares Quadratic Programming
method = :LD_CCSAQ
alg = NLoptAlg(method)
options = NLoptOptions(maxeval=maxeval)

# Optimize model
r = optimize(model, alg, [min_total_volume + 5], options = options)

best_solution = r.minimizer
best_profit = -r.minimum

scatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],
    label=&quot;NLOpt-$(method) - OPF Calls:$(storage_profit_function.fcalls)&quot;,
)

plt_visited = deepcopy(plt_range)

storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time

scatter!(plt_visited, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, 
    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=&quot;Visited&quot;,
    title=&quot;LD_CCSAQ&quot;
)

plot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], 
(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,
    xlabel=&quot;Time (x OPF)&quot;,
    ylabel=&quot;Optimality Gap (%)&quot;,
    ylim=(0.0,1.0),
    legend=false,
    title=&quot;LD_CCSAQ&quot;
)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../Optim/">Optim.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 2 June 2023 02:51">Friday 2 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
