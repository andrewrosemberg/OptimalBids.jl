var documenterSearchIndex = {"docs":
[{"location":"api/#Api","page":"API","title":"Api","text":"","category":"section"},{"location":"api/#OptimalBids","page":"API","title":"OptimalBids","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids]","category":"page"},{"location":"api/#OptimalBids.Market","page":"API","title":"OptimalBids.Market","text":"Market\n\nMutable Structure of a market instance.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.build_market-Union{Tuple{M}, Tuple{Type{M}, Vararg{Any}}} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.build_market","text":"build_market(::Type{Market}, params...) -> Market\n\nBuilds market of type Market using provided parameters (params).\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.calculate_profit-Tuple{M} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.calculate_profit","text":"calculate_profit(market::Market) -> NamedTuple{(:cleared_volumes, :clearing_prices, :profit), Tuple{Vector{Int}, Vector{Int}, Vector{Int}}}\n\nRetrieves strategic agent's cleared volumes and prices from the market and calculates per bid profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.change_bids!-Union{Tuple{M}, Tuple{M, Vector}} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.change_bids!","text":"change_bids!(market::Market, new_bids::Vector)\n\nChanges strategic agent's bids in the market to new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{M} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.clear_market!","text":"clear_market!(market::Market)\n\nClears the market.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_curve!-Tuple{OptimalBids.Market, Vector{<:AbstractVector}}","page":"API","title":"OptimalBids.profit_curve!","text":"profit_curve!(market::Market, range_new_bids::Vector{Vector{Any}}) -> Vector{Float64}\n\nConstructs profit curve for bids provided in range_new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_for_bid!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.profit_for_bid!","text":"profit_for_bid!(market::Market, new_bids::Vector{Any}) -> Float64\n\nCalculates overall profit when market is cleared with new_bids. This function will sequentiall call change_bids!, clear_market! and calculate_profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#PowerModelsMarkets","page":"API","title":"PowerModelsMarkets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids.PowerModelsMarkets]\nPrivate = false","category":"page"},{"location":"api/#OptimalBids.PowerModelsMarkets","page":"API","title":"OptimalBids.PowerModelsMarkets","text":"PowerModelsMarkets\n\nSubModule that implements interfact with PowerModels.jl\n\n\n\n\n\n","category":"module"},{"location":"api/#OptimalBids.PowerModelsMarkets.PowerModelsMarket","page":"API","title":"OptimalBids.PowerModelsMarkets.PowerModelsMarket","text":"PowerModelsMarket <: OptimalBids.Market\n\nEnergy-Market type that uses PowerModels' OPF to clear the auction.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.PowerModelsMarkets.add_generator-Tuple{Dict, Int64}","page":"API","title":"OptimalBids.PowerModelsMarkets.add_generator","text":"add_generator(nw_data::Dict, bus_index::Int) -> String\n\nAdds generator at bus with index bus_index in grid data (nw_data), and returns dictionary key for the new generator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.PowerModelsMarkets.profit_and_gradient_for_bid!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.PowerModelsMarkets.profit_and_gradient_for_bid!","text":"profit_and_gradient_for_bid!(market::Market, new_bids::Vector{Any}) -> Float64, Float64\n\nCalculates overall profit when market is cleared with new_bids and its gradient w.r.t the vector of bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Any, Any, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     ::Type{PowerModelsMarket},     networkdata,     strategicgenerators,     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.buildopf,     assert_consistency=true, )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\nassert_consistency=true: Boolean to force check if strategic generators indexes (in strategic_generators) reference generators located at the specified bus_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     market::Type{PowerModelsMarket},     networkdata::Dict,     genindexes::AbstractVector{String},     busindexes::AbstractVector{String},     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.build_opf,     kwards..., )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nbus_indexes::AbstractVector{String}: Vector of strategic generators' bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     market::Type{PowerModelsMarket},     networkdata::Dict,     genindexes::AbstractVector{String},     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.buildopf, )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{OptimalBids.PowerModelsMarkets.PowerModelsMarket}","page":"API","title":"OptimalBids.clear_market!","text":"OptimalBids.clear_market!(market::PowerModelsMarket)\n\nClears market and stores result's dictionary in result.\n\n\n\n\n\n","category":"method"},{"location":"api/#PowerModels.instantiate_model-Tuple{OptimalBids.PowerModelsMarkets.PowerModelsMarket}","page":"API","title":"PowerModels.instantiate_model","text":"PowerModels.instantiate_model(market::PowerModelsMarket)\n\nInstantiates PowerModels Model.\n\n\n\n\n\n","category":"method"},{"location":"examples/GaussianProcesses/#Example-Fitting-a-Gaussian-Process-to-the-profit-curve-(using-AbstractGPs.jl)","page":"AbstractGPs.jl","title":"Example Fitting a Gaussian Process to the profit curve (using AbstractGPs.jl)","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"This a example on how to use AbstractGPs.jl to fit a Gaussian Process (GP) to the profit curve of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"For this example, we will use a market of type PowerModelsMarkets which represents an energy spot market.\nCase instance is IEEE 118 Bus Case\nTo ilustrate a situation where the company defines the distribution of volume across it's assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.\nWe will use Optim.jl for the MLE of the tested kernels' hyperparameters. ","category":"page"},{"location":"examples/GaussianProcesses/#Include-Needed-Packages","page":"AbstractGPs.jl","title":"Include Needed Packages","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\nusing JuMP: optimizer_with_attributes\n\nusing AbstractGPs\nusing KernelFunctions\n\nusing Optim\nusing ParameterHandling\nusing Zygote\nusing ParameterHandling: flatten\n\nusing Plots # For some evaluation plots at the end\nusing Plots.PlotMeasures\nusing Downloads # To download Test Cases\n","category":"page"},{"location":"examples/GaussianProcesses/#Case-Definition","page":"AbstractGPs.jl","title":"Case Definition","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n# Read market data from IEEE 118 bus case\ncase_name = \"pglib_opf_case118_ieee.m\"\nDATA_DIR = mktempdir()\ncase_file_path = joinpath(DATA_DIR, case_name)\nDownloads.download(\"https://raw.githubusercontent.com/power-grid-lib/pglib-opf/01681386d084d8bd03b429abcd1ee6966f68b9a3/\" * case_name, case_file_path)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Measure maximum load\nmax_load = sum(load[\"pd\"] for load in values(network_data[\"load\"])) * network_data[\"baseMVA\"]\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n","category":"page"},{"location":"examples/GaussianProcesses/#OptimalBids-API","page":"AbstractGPs.jl","title":"OptimalBids API","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    optimizer_with_attributes(Clp.Optimizer, \"LogLevel\" => 0),\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.\nusing Random\nrng = MersenneTwister(0)\noffer_weights = rand(rng, num_strategic_buses)\noffer_weights = offer_weights/ sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 655.0\nrange_mul_factor = min_total_volume:1.0:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\n","category":"page"},{"location":"examples/GaussianProcesses/#Optim-API","page":"AbstractGPs.jl","title":"Optim API","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\nfunction bfgs(objective, initial_params; verbose=false)\n   training_results = Optim.optimize(\n        objective,\n        θ -> only(Zygote.gradient(objective, θ)),\n        initial_params,\n        LBFGS(\n            alphaguess = Optim.LineSearches.InitialStatic(scaled=true),\n            linesearch = Optim.LineSearches.BackTracking(),\n        ),\n        Optim.Options(show_trace = verbose);\n        inplace=false,\n    )\n\n   return (training_results.minimum, training_results.minimizer)\nend\n\nfunction multi_start_hyperopt(target, algorithm, num_iterations, initial_initial_params; update_initials = (θ_last, θ_best, obj_diff) -> rand(length(θ_last)), verbose=false, kwargs...)\n    θ_initials = Array{Float64, 2}(undef, num_iterations, length(initial_initial_params));\n    vistited_best_fs = Array{Float64}(undef, num_iterations);\n    best_θ = fill(1/length(initial_initial_params), length(initial_initial_params))\n    best_f = target(best_θ)\n    last_θ = best_θ\n    last_f = best_f\n    for i = 1:num_iterations\n        try\n            (last_f, last_θ) = algorithm(target, update_initials(last_θ, best_θ, last_f-best_f); verbose=verbose, kwargs...)\n        catch\n            println(\"SHIT\")\n        end\n        θ_initials[i,:] .= last_θ\n        if last_f < best_f\n            best_f = last_f\n            best_θ = last_θ\n        end\n        vistited_best_fs[i] = best_f\n    end\n    return best_f, best_θ, θ_initials, vistited_best_fs\nend\n","category":"page"},{"location":"examples/GaussianProcesses/#AbstractGPs-Interface","page":"AbstractGPs.jl","title":"AbstractGPs Interface","text":"","category":"section"},{"location":"examples/GaussianProcesses/#Data","page":"AbstractGPs.jl","title":"Data","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n# Randomly choose observed data\nnumber_samples = 9\nidx = [1; rand(2:size(range_mul_factor,1), number_samples)]\nx = collect(range_mul_factor)[idx]\ny = p_curve[idx]\n\nplt_comp = plot(collect(range_mul_factor) * 100 / max_load, p_curve,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (USD)\",\n    size=(900, 600), \n    title=\"Kernel Comparison\", \n    xlabel=\"Bid Volume (% Market Share)\",\n    legend=:outertopright,\n    color=\"black\",\n    width=3,\n    left_margin=10mm,\n    bottom_margin=10mm,\n);\nscatter!(plt_comp, x .* 100 ./ max_load, y; label=\"Data\");\n\nplt_comp","category":"page"},{"location":"examples/GaussianProcesses/#Matern32Kernel","page":"AbstractGPs.jl","title":"Matern32Kernel","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n## Define GP prior with Matern32Kernel\nflat_initial_params, unflatten = flatten((;\n    var_kernel = bounded(10.0, 1.0, 1e8),\n    λ = bounded(0.005, 0.0, 0.01),\n))\n\n# Construct a function to unpack flattened parameters and pull out the raw values.\nunpack = ParameterHandling.value ∘ unflatten\nparams = unpack(flat_initial_params)\n\nfunction build_gp(params)\n    return GP(params.var_kernel * Matern52Kernel() ∘ ScaleTransform(params.λ))\nend\n\n# Define MLE objective\nfunction objective(params)\n    f = build_gp(unpack(params))\n    return -logpdf(f(x, 0.001), y)\nend\n\n# Optimise using Optim\n(best_f, best_θ, θ_initials, vistited_best_fs) = multi_start_hyperopt(objective, bfgs, 100, flat_initial_params)\n\n# Extracting the optimal values of the parameters\noptimal_params = unpack(best_θ)\n\n# Final GP\nf = build_gp(optimal_params)\n\n# Finite projection of `f` at inputs `x`.\n# Added Gaussian noise with variance 0.001.\nfx = f(x, 0.001)\n\n# Exact posterior given `y`. This is another GP.\np_fx = posterior(fx, y)\n\n# Plot posterior.\nplot!(plt_comp, collect(range_mul_factor) * 100 / max_load, p_fx(collect(range_mul_factor)); label=\"Posterior - \" * string(Matern32Kernel))","category":"page"},{"location":"examples/GaussianProcesses/#RationalKernel","page":"AbstractGPs.jl","title":"RationalKernel","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n## Define GP prior with RationalKernel\nflat_initial_params, unflatten = flatten((;\n    var_kernel = bounded(10.0, 6.0, 1e8),\n    λ = bounded(0.005, 0.0, 0.01),\n    α = positive(0.05),\n))\n\n# Construct a function to unpack flattened parameters and pull out the raw values.\nunpack = ParameterHandling.value ∘ unflatten\nparams = unpack(flat_initial_params)\n\nfunction build_gp(params)\n    return GP(params.var_kernel * RationalKernel(α=params.α) ∘ ScaleTransform(params.λ))\nend\n\n# Define MLE objective\nfunction objective(params)\n    f = build_gp(unpack(params))\n    return -logpdf(f(x, 0.001), y)\nend\n\n# Optimise using Optim\n(best_f, best_θ, θ_initials, vistited_best_fs) = multi_start_hyperopt(objective, bfgs, 100, flat_initial_params)\n\n# Extracting the optimal values of the parameters\noptimal_params = unpack(best_θ)\n\n# Final GP\nf = build_gp(optimal_params)\n\n# Finite projection of `f` at inputs `x`.\n# Added Gaussian noise with variance 0.001.\nfx = f(x, 0.001)\n\n# Exact posterior given `y`. This is another GP.\np_fx = posterior(fx, y)\n\n# Plot posterior.\nplot!(plt_comp, collect(range_mul_factor) * 100 / max_load, p_fx(collect(range_mul_factor)); label=\"Posterior - \" * string(RationalKernel))","category":"page"},{"location":"examples/GaussianProcesses/#FBMKernel","page":"AbstractGPs.jl","title":"FBMKernel","text":"","category":"section"},{"location":"examples/GaussianProcesses/","page":"AbstractGPs.jl","title":"AbstractGPs.jl","text":"\n## Define GP prior with FBMKernel\nflat_initial_params, unflatten = flatten((;\n    var_kernel = bounded(10.0, 6.0, 1e8),\n    λ = bounded(0.005, 0.0, 0.01),\n    h = bounded(0.05, 0.0, 1.0),\n))\n\n# Construct a function to unpack flattened parameters and pull out the raw values.\nunpack = ParameterHandling.value ∘ unflatten\nparams = unpack(flat_initial_params)\n\nfunction build_gp(params)\n    return GP(params.var_kernel * FBMKernel(h=params.h) ∘ ScaleTransform(params.λ))\nend\n\n# Define MLE objective\nfunction objective(params)\n    f = build_gp(unpack(params))\n    return -logpdf(f(x, 0.001), y)\nend\n\n# Optimise using Optim\n(best_f, best_θ, θ_initials, vistited_best_fs) = multi_start_hyperopt(objective, bfgs, 100, flat_initial_params)\n\n# Extracting the optimal values of the parameters\noptimal_params = unpack(best_θ)\n\n# Final GP\nf = build_gp(optimal_params)\n\n# Finite projection of `f` at inputs `x`.\n# Added Gaussian noise with variance 0.001.\nfx = f(x, 0.001)\n\n# Exact posterior given `y`. This is another GP.\np_fx = posterior(fx, y)\n\n# Plot posterior.\nplot!(plt_comp, collect(range_mul_factor) * 100 / max_load, p_fx(collect(range_mul_factor)); label=\"Posterior - \" * string(FBMKernel))","category":"page"},{"location":"examples/Nonconvex/#Profit-Maximization-Example","page":"Nonconvex.jl","title":"Profit Maximization Example","text":"","category":"section"},{"location":"examples/Nonconvex/#using-Nonconvex.jl","page":"Nonconvex.jl","title":"using Nonconvex.jl","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"This a example on how to use Nonconvex.jl to maximize the profit of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"For this example, we will use a market of type PowerModelsMarkets which represents an energy spot market.\nCase instance is IEEE 118 Bus Case\nTo ilustrate a situation where the company defines the distribution of volume across it's assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.  ","category":"page"},{"location":"examples/Nonconvex/#Include-Needed-Packages","page":"Nonconvex.jl","title":"Include Needed Packages","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\nusing JuMP: optimizer_with_attributes\n\nusing Nonconvex\nusing NonconvexIpopt # Nonconvex.@load Ipopt\nusing NonconvexBayesian # Nonconvex.@load BayesOpt\nusing Zygote\n\nusing AbstractGPs\nusing KernelFunctions\n\nusing Plots # For some evaluation plots at the end\nusing Plots.PlotMeasures\nusing Downloads # To download Test Cases\n","category":"page"},{"location":"examples/Nonconvex/#Case-Definition","page":"Nonconvex.jl","title":"Case Definition","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Read market data from IEEE 118 bus case\ncase_name = \"pglib_opf_case118_ieee.m\"\nDATA_DIR = mktempdir()\ncase_file_path = joinpath(DATA_DIR, case_name)\nDownloads.download(\"https://raw.githubusercontent.com/power-grid-lib/pglib-opf/01681386d084d8bd03b429abcd1ee6966f68b9a3/\" * case_name, case_file_path)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Measure maximum load\nmax_load = sum(load[\"pd\"] for load in values(network_data[\"load\"])) * network_data[\"baseMVA\"]\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n","category":"page"},{"location":"examples/Nonconvex/#OptimalBids-API","page":"Nonconvex.jl","title":"OptimalBids API","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    optimizer_with_attributes(Clp.Optimizer, \"LogLevel\" => 0),\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.\nusing Random\nrng = MersenneTwister(666)\noffer_weights = rand(rng, num_strategic_buses)\noffer_weights = offer_weights / sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 155.0\nrange_mul_factor = min_total_volume:1.0:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\nmaximum_pq_curve, argmax_pq_curve = findmax(p_curve)\n\n# Mesure time to change bids and solve opf\nnum_opfs = 10\nopf_time = @elapsed [profit_for_bid!(market, offer_weights) for _ = 1:num_opfs]\nopf_time /= num_opfs\n\n# Let's plot and see how the range profit evaluatiuon went:\nplt_range = plot(collect(range_mul_factor) * 100 / max_load, p_curve,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (USD)\",\n    xlabel=\"Bid Volume (% Market Share)\",\n    legend=:outertopright,\n    left_margin=10mm,\n    bottom_margin=10mm,\n    size=(900, 600),\n    color=:black,\n    width=2.0\n);\nplt_comp = deepcopy(plt_range);","category":"page"},{"location":"examples/Nonconvex/#Nonconvex-API","page":"Nonconvex.jl","title":"Nonconvex API","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Nonconvex needs a minimization objective function that only receives the decision vector.\nfunction profit_function(total_volume)\n    return - profit_for_bid!(market, offer_weights .* first(total_volume))\nend\n\nmutable struct StorageCallbackProfit <: Function\n    start_time::Float64\n    fcalls::Int\n    visited_objective::Array{Float64}\n    visited_volumes::Array{Float64}\n    visited_times::Array{Float64}\n    projection::Array{Float64}\nend\nStorageCallbackProfit(maxiter, start_time; projection=offer_weights) = StorageCallbackProfit(start_time, 0, \n    Array{Float64}(undef, 5 * maxiter),\n    Array{Float64}(undef, 5 * maxiter),\n    Array{Float64}(undef, 5 * maxiter),\n    projection\n)\n\nfunction (callback::StorageCallbackProfit)(total_volume)\n    Zygote.@ignore callback.fcalls += 1\n    Zygote.@ignore callback.visited_volumes[callback.fcalls] = sum(callback.projection .* total_volume)\n    Zygote.@ignore callback.visited_times[callback.fcalls] = time() - callback.start_time\n    obj = profit_for_bid!(market, callback.projection .* total_volume)\n    Zygote.@ignore callback.visited_objective[callback.fcalls] = obj\n    return - obj\nend\n","category":"page"},{"location":"examples/Nonconvex/#Motivation-for-fixed-weights","page":"Nonconvex.jl","title":"Motivation for fixed weights","text":"","category":"section"},{"location":"examples/Nonconvex/#Random-bids-range-evaluation","page":"Nonconvex.jl","title":"Random bids range evaluation","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nnumber_of_curves = 30\np_curves = Array{Any}(undef, number_of_curves)\n\nmin_total_volume = 0.0\nmax_total_volume = 655.0\nrange_mul_factor = min_total_volume:5.0:max_total_volume\n\nnum_points = length(range_mul_factor)\n\nfor i = 1:2\n    offer_weights = rand(rng, num_strategic_buses)\n    offer_weights = offer_weights / sum(offer_weights)\n\n    # However, the decision maker is allowed to increase all bids evenly:\n    bid_range = [offer_weights .* [j] for j in range_mul_factor]\n    p_curves[i] = profit_curve!(market, bid_range)\nend\n\nfor i = 3:number_of_curves\n    mul_factor = rand(rng, max_total_volume/4:max_total_volume)\n    offer_weights_up = rand(rng, num_strategic_buses)\n    offer_weights_up = offer_weights_up / sum(offer_weights_up) * mul_factor\n    offer_weights_down = rand(rng, num_strategic_buses)\n    offer_weights_down = offer_weights_down / sum(offer_weights_down) * mul_factor\n    norm(offer_weights_up - offer_weights_down, 1)\n    direction = offer_weights_up - offer_weights_down\n\n    # However, the decision maker is allowed to increase all bids evenly:\n    bid_range = [offer_weights_down + direction * i for i in range(0,1, num_points)]\n    p_curves[i] = profit_curve!(market, bid_range)\nend\n\nplot(range(-100,100, num_points), p_curves,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (USD)\",\n    xlabel=\"Relative Distance (%)\",\n    legend=false,\n    left_margin=10mm,\n    bottom_margin=10mm,\n    size=(900, 600)\n)","category":"page"},{"location":"examples/Nonconvex/#Individual-bids","page":"Nonconvex.jl","title":"Individual bids","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nmin_total_volume = 0.0\nmax_total_volume = 155.0\nrange_mul_factor = min_total_volume:1.0:max_total_volume\n\nplt_comp_individual = plot(collect(range_mul_factor) * 100 / max_load, p_curve,\n    label=\"Regularized Benchmark\",\n    ylabel=\"Profit (USD)\",\n    xlabel=\"Bid Volume (% Market Share)\",\n    legend=:outertopright,\n    left_margin=10mm,\n    bottom_margin=10mm,\n    size=(900, 600),\n    color=:black,\n    width=2.0\n);\n\nfor i = 1:num_strategic_buses\n    ind_offer = zeros(num_strategic_buses)\n    ind_offer[i] = 1.0\n    bid_range_individual = [ind_offer .* [i] for i in range_mul_factor]\n    p_curve_individual = profit_curve!(market, bid_range_individual)\n    plot!(plt_comp_individual, collect(range_mul_factor) * 100 / max_load, p_curve_individual, label=\"Node $i\")\nend\n\nplot(plt_comp_individual)","category":"page"},{"location":"examples/Nonconvex/#Unconstrained-bids","page":"Nonconvex.jl","title":"Unconstrained bids","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\n# ps.: Currently, no option for limiting fcalls.\nmaxiter = 60\n\nstorage_profit_function = StorageCallbackProfit(maxiter * 10, time(); projection=ones(num_strategic_buses))\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, storage_profit_function, flags = [:expensive])\naddvar!(model, fill(min_total_volume, num_strategic_buses), fill(max_total_volume * 2, num_strategic_buses))\nadd_ineq_constraint!(model, x -> sum(x) - max_total_volume * 8)\n\n# Solution Method: Bayesian Optimization\nalg = BayesOptAlg(IpoptAlg())\noptions = BayesOptOptions(\n    sub_options = IpoptOptions(max_iter = 20, print_level = 0),\n    ninit=3,\n    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5, initialize=true, postoptimize=false,\n    kernel= RationalKernel(α=2.27e8) ∘ ScaleTransform(0.01),\n    noise=0.001,\n    std_multiple=8.67e4,\n    fit_prior=false # not working with custom priors\n)\n\n# Optimize model:\nr_bayes = optimize(model, alg, offer_weights * 5; options = options)\n\nbest_solution = r_bayes.minimizer\nbest_profit = -r_bayes.minimum\n\nplt_comp_individual = plot(collect(range_mul_factor) * 100 / max_load, p_curve,\n    label=\"Regularized Benchmark\",\n    ylabel=\"Profit (USD)\",\n    xlabel=\"Bid Volume (% Market Share)\",\n    legend=:outertopright,\n    left_margin=10mm,\n    bottom_margin=10mm,\n    size=(900, 600),\n    color=:black,\n    width=2.0\n);\n\nscatter!(plt_comp_individual, [sum(best_solution)] * 100 / max_load, [best_profit],\n    label=\"Multinode BayesOpt - OPF Calls:$(storage_profit_function.fcalls)\",\n)\n\nplt_surrogate = deepcopy(plt_comp_individual);\n\nrange_mul_factor_multi_node = min_total_volume:1.0:max_load\nbid_range = [best_solution .* [i / sum(best_solution)] for i in range_mul_factor_multi_node]\np_curve_multi_node = profit_curve!(market, bid_range)\n\nplot!(plt_surrogate, collect(range_mul_factor_multi_node) * 100 / max_load, p_curve_multi_node; \n    label=\"Multi Node Range Evaluation\",\n    color=\"orange\"\n);\n\nscatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, \n    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=\"Visited\",\n    color=\"orange\"\n)","category":"page"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"storage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time\n\nplot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], \n(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,\n    xlabel=\"Time (x OPF)\",\n    ylabel=\"Optimality Gap (%)\",\n    ylim=(0.0,1.0),\n    legend=false\n)","category":"page"},{"location":"examples/Nonconvex/#BayesOpt-(0-Order)","page":"Nonconvex.jl","title":"BayesOpt (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\n# ps.: Currently, no option for limiting fcalls.\nmaxiter = 10\n\nstorage_profit_function = StorageCallbackProfit(maxiter * 10, time())\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, storage_profit_function, flags = [:expensive])\naddvar!(model, [min_total_volume], [max_total_volume])\nadd_ineq_constraint!(model, x -> sum(x) - max_total_volume)\n\n# Solution Method: Bayesian Optimization\nalg = BayesOptAlg(IpoptAlg())\noptions = BayesOptOptions(\n    sub_options = IpoptOptions(max_iter = 20, print_level = 0),\n    # ninit=Int(floor(maxiter / 5)),\n    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5, initialize=true, postoptimize=false,\n    kernel= RationalKernel(α=2.27e8) ∘ ScaleTransform(0.01),\n    noise=0.001,\n    std_multiple=8.67e4,\n    fit_prior=false # not working with custom priors\n)\n\n# Optimize model:\nr_bayes = optimize(model, alg, [max_total_volume / 2]; options = options)\n\nbest_solution = r_bayes.minimizer\nbest_profit = -r_bayes.minimum\n\nscatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],\n    label=\"BayesOpt - OPF Calls:$(storage_profit_function.fcalls)\",\n)\n\nplt_surrogate = deepcopy(plt_range);\n\nup_surrugate = -getproperty.(r_bayes.surrogates[1].(range_mul_factor), :lo)\nlb_surrugate = -getproperty.(r_bayes.surrogates[1].(range_mul_factor), :hi)\nstd_surrugate = (up_surrugate .- lb_surrugate) / 2\nmed_surrugate = lb_surrugate + std_surrugate\n\nstorage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time\n\nplot!(plt_surrogate, range_mul_factor * 100 / max_load, med_surrugate,\n    ribbon=std_surrugate,\n    title=\"BayesOpt Analysis\",\n    label=\"Surrogate Function\",\n);\nscatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, \n    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=\"Visited\"\n)","category":"page"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nplot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], \n(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,\n    xlabel=\"Time (x OPF)\",\n    ylabel=\"Optimality Gap (%)\",\n    ylim=(0.0,1.0),\n    legend=false\n)","category":"page"},{"location":"examples/Nonconvex/#NLopt-BOBYQA-(0-Order)","page":"Nonconvex.jl","title":"NLopt - BOBYQA (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexNLopt\n\nmaxeval = 50\nstorage_profit_function = StorageCallbackProfit(maxeval * 10, time())\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, storage_profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Sequential Least-Squares Quadratic Programming\nmethod = :LN_BOBYQA\nalg = NLoptAlg(:LN_BOBYQA)\noptions = NLoptOptions(maxeval=maxeval)\n\n# Optimize model\nr = optimize(model, alg, [min_total_volume]; options = options)\n\nbest_solution = r.minimizer\nbest_profit = -r.minimum\n\nscatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],\n    label=\"NLOpt-$(method) - OPF Calls:$(storage_profit_function.fcalls)\",\n);\n\n\nplt_surrogate = deepcopy(plt_range);\n\nstorage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time\n\nscatter!(plt_surrogate, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, \n    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=\"Visited\",\n    title=\"BOBYQA\"\n)\n\nplot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], \n(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,\n    xlabel=\"Time (x OPF)\",\n    ylabel=\"Optimality Gap (%)\",\n    ylim=(0.0,1.0),\n    legend=false,\n    title=\"BOBYQA\"\n)","category":"page"},{"location":"examples/Nonconvex/#NonconvexMultistart-GPSampler-(0-Order)","page":"Nonconvex.jl","title":"NonconvexMultistart - GPSampler (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexMultistart\n\nmaxiter = 10\nstorage_profit_function = StorageCallbackProfit(maxiter * 10, time())\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, storage_profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Hyperopt\nmethod = :Hyperopt\nalg = HyperoptAlg(IpoptAlg())\noptions = HyperoptOptions(\n    sub_options = IpoptOptions(max_iter = maxiter), sampler = GPSampler(),\n    iters = 2,\n    keep_all=true\n)\n\n# Optimize model\nr_hyp = optimize(model, alg, [max_total_volume / 2], options = options)\n\nbest_solution = r_hyp.minimizer\nbest_profit = -r_hyp.minimum\n\nscatter!(plt_comp, best_solution * 100 / max_load, [best_profit],\n    label=\"$(method) Offer - OPF Calls:$(storage_profit_function.fcalls)\",\n);\n\nplt_visited = deepcopy(plt_range)\n\nstorage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time\n\nscatter!(plt_visited, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, \n    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=\"Visited\"\n)\n\nplot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], \n(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,\n    xlabel=\"Time (x OPF)\",\n    ylabel=\"Optimality Gap (%)\",\n    ylim=(0.0,1.0),\n    legend=false\n)","category":"page"},{"location":"examples/Nonconvex/#Profit-Comparison-NLP-0-Order-Strategies","page":"Nonconvex.jl","title":"Profit Comparison NLP 0-Order Strategies","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nplot(plt_comp, margin=5Plots.mm,\n    title=\"Profit Comparison NLP Strategies\",\n)","category":"page"},{"location":"examples/Nonconvex/#NLopt-CCSAQ-(1-Order)","page":"Nonconvex.jl","title":"NLopt - CCSAQ (1-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexNLopt\n\nmaxeval = 50\nstorage_profit_function = StorageCallbackProfit(maxeval * 10, time())\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, storage_profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Sequential Least-Squares Quadratic Programming\nmethod = :LD_CCSAQ\nalg = NLoptAlg(method)\noptions = NLoptOptions(maxeval=maxeval)\n\n# Optimize model\nr = optimize(model, alg, [min_total_volume + 5], options = options)\n\nbest_solution = r.minimizer\nbest_profit = -r.minimum\n\nscatter!(plt_comp, [best_solution] * 100 / max_load, [best_profit],\n    label=\"NLOpt-$(method) - OPF Calls:$(storage_profit_function.fcalls)\",\n)\n\nplt_visited = deepcopy(plt_range)\n\nstorage_profit_function.visited_times = storage_profit_function.visited_times ./ opf_time\n\nscatter!(plt_visited, storage_profit_function.visited_volumes[1:storage_profit_function.fcalls] * 100 / max_load, \n    storage_profit_function.visited_objective[1:storage_profit_function.fcalls]; label=\"Visited\",\n    title=\"LD_CCSAQ\"\n)\n\nplot(storage_profit_function.visited_times[1:storage_profit_function.fcalls], \n(maximum_pq_curve .- accumulate(max, storage_profit_function.visited_objective[1:storage_profit_function.fcalls])) ./ maximum_pq_curve,\n    xlabel=\"Time (x OPF)\",\n    ylabel=\"Optimality Gap (%)\",\n    ylim=(0.0,1.0),\n    legend=false,\n    title=\"LD_CCSAQ\"\n)","category":"page"},{"location":"examples/Optim/#Profit-Maximization-Example","page":"Optim.jl","title":"Profit Maximization Example","text":"","category":"section"},{"location":"examples/Optim/#using-Optim.jl","page":"Optim.jl","title":"using Optim.jl","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"This a example on how to use Optim.jl to maximize the profit of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"For this example, we will use a market of type PowerModelsMarkets which represents an energy spot market.\nCase instance is IEEE 118 Bus Case\nTo ilustrate a situation where the company defines the distribution of volume across it's assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.  ","category":"page"},{"location":"examples/Optim/#Include-Needed-Packages","page":"Optim.jl","title":"Include Needed Packages","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\nusing JuMP: optimizer_with_attributes\n\nusing Optim\n\nusing Plots # For some evaluation plots at the end\nusing Plots.PlotMeasures\nusing Downloads # To download Test Cases\n","category":"page"},{"location":"examples/Optim/#Case-Definition","page":"Optim.jl","title":"Case Definition","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Read market data from IEEE 118 bus case\ncase_name = \"pglib_opf_case118_ieee.m\"\nDATA_DIR = mktempdir()\ncase_file_path = joinpath(DATA_DIR, case_name)\nDownloads.download(\"https://raw.githubusercontent.com/power-grid-lib/pglib-opf/01681386d084d8bd03b429abcd1ee6966f68b9a3/\" * case_name, case_file_path)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n","category":"page"},{"location":"examples/Optim/#OptimalBids-API","page":"Optim.jl","title":"OptimalBids API","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    optimizer_with_attributes(Clp.Optimizer, \"LogLevel\" => 0),\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.\nusing Random\nrng = MersenneTwister(0)\noffer_weights = rand(rng, num_strategic_buses)\noffer_weights = offer_weights/ sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 65.0\nrange_mul_factor = min_total_volume:0.1:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\n\n# Let's plot and see how the range profit evaluatiuon went:\nplt_range = plot(collect(range_mul_factor), p_curve,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (\\$)\",\n    xlabel=\"Multiplicative Factor\",\n    legend=:outertopright,\n    left_margin=10mm,\n    bottom_margin=10mm,\n);\nplt_comp = deepcopy(plt_range);","category":"page"},{"location":"examples/Optim/#Profit-Function","page":"Optim.jl","title":"Profit Function","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Optim needs a minimization objective function that only receives the decision vector.\nfunction profit_function(total_volume)\n    global fcalls += 1\n    return - profit_for_bid!(market, offer_weights .* total_volume[1])\nend\n","category":"page"},{"location":"examples/Optim/#NelderMead-(0-Order)","page":"Optim.jl","title":"NelderMead (0-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\n# Solve Optim optimization model:\nlower = [min_total_volume]\nupper = [max_total_volume]\ninitial_x = [min_total_volume] .+ 0.001 # Initial value cannot be on boundary value\n\n# Limiting fcalls.\nfunction advanced_fcall_control(x)\n    println(\" * Fcalls so far:     \", fcalls)\n    if fcalls >= maxiter\n        return true\n    end\n    println()\n    false\nend\n\ninner_optimizer = NelderMead()\nresults = Optim.optimize(profit_function, lower, upper, initial_x, Fminbox(inner_optimizer), Optim.Options(f_calls_limit=maxiter, callback = advanced_fcall_control, store_trace=true))\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"NelderMead - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"examples/Optim/#LBFGS-(1-Order)","page":"Optim.jl","title":"LBFGS (1-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Profit and gradient\nusing LinearAlgebra\n\nfunction fg!(F,G,total_volume)\n    y, Δ = profit_and_gradient_for_bid!(market, offer_weights .* total_volume[1])\n    global fcalls += 1\n\n    isnothing(G) || copyto!(G, dot(Δ, offer_weights))\n    isnothing(F) || return y\n\n    nothing\nend\n\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\ninner_optimizer = LBFGS()\nresults = Optim.optimize(Optim.only_fg!(fg!), lower, upper, initial_x, Fminbox(inner_optimizer), Optim.Options(f_calls_limit=maxiter, callback = advanced_fcall_control, store_trace=true))\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"LBFGS - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"examples/Optim/#Brent-(0-Order)","page":"Optim.jl","title":"Brent (0-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\nfunction profit_function(total_volume)\n    global fcalls += 1\n    return - profit_for_bid!(market, offer_weights .* total_volume)\nend\nresults = Optim.optimize(profit_function, min_total_volume, max_total_volume, Brent(); callback = advanced_fcall_control, store_trace=true)\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"Brent - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBids","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#99DDFF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/andrewrosemberg/OptimalBids.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star andrewrosemberg/OptimalBids.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#OptimalBids","page":"Home","title":"OptimalBids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OptimalBids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple Package to help evaluate bids in markets/auctions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add OptimalBids","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The framework used is based around the dispatch of the following functions for specified markets (subtypes of the core abstract type Market): build_market, change_bids!, clear_market!, calculate_profit (see docstrings for more info - e.g. @doc change_bids!). I.e. these are the functions that need to be implemented for each market type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the functions profit_for_bid!, profit_curve! are implemented in a reasonably generic way, allowing users to dispatch them with any new market. (see docstrings for more info - e.g. @doc profit_for_bid!).","category":"page"}]
}
