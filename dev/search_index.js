var documenterSearchIndex = {"docs":
[{"location":"api/#Api","page":"API","title":"Api","text":"","category":"section"},{"location":"api/#OptimalBids","page":"API","title":"OptimalBids","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids]","category":"page"},{"location":"api/#OptimalBids.Market","page":"API","title":"OptimalBids.Market","text":"Market\n\nMutable Structure of a market instance.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.Market}, Vararg{Any}}","page":"API","title":"OptimalBids.build_market","text":"build_market(::Type{Market}, params...) -> Market\n\nBuilds market of type Market using provided parameters (params).\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.calculate_profit-Tuple{OptimalBids.Market}","page":"API","title":"OptimalBids.calculate_profit","text":"calculate_profit(market::Market) -> NamedTuple{(:cleared_volumes, :clearing_prices, :profit), Tuple{Vector{Int}, Vector{Int}, Vector{Int}}}\n\nRetrieves strategic agent's cleared volumes and prices from the market and calculates per bid profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.change_bids!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.change_bids!","text":"change_bids!(market::Market, new_bids::Vector)\n\nChanges strategic agent's bids in the market to new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{OptimalBids.Market}","page":"API","title":"OptimalBids.clear_market!","text":"clear_market!(market::Market)\n\nClears the market.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_curve!-Tuple{OptimalBids.Market, Vector{<:AbstractVector}}","page":"API","title":"OptimalBids.profit_curve!","text":"profit_curve!(market::Market, range_new_bids::Vector{Vector{Any}}) -> Vector{Float64}\n\nConstructs profit curve for bids provided in range_new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_for_bid!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.profit_for_bid!","text":"profit_for_bid!(market::Market, new_bids::Vector{Any}) -> Float64\n\nCalculates overall profit when market is cleared with new_bids. This function will sequentiall call change_bids!, clear_market! and calculate_profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#PowerModelsMarkets","page":"API","title":"PowerModelsMarkets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids.PowerModelsMarkets]\nPrivate = false","category":"page"},{"location":"api/#OptimalBids.PowerModelsMarkets","page":"API","title":"OptimalBids.PowerModelsMarkets","text":"PowerModelsMarkets\n\nSubModule that implements interfact with PowerModels.jl\n\n\n\n\n\n","category":"module"},{"location":"api/#OptimalBids.PowerModelsMarkets.PowerModelsMarket","page":"API","title":"OptimalBids.PowerModelsMarkets.PowerModelsMarket","text":"PowerModelsMarket <: OptimalBids.Market\n\nEnergy-Market type that uses PowerModels' OPF to clear the auction.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.PowerModelsMarkets.add_generator-Tuple{Dict, Int64}","page":"API","title":"OptimalBids.PowerModelsMarkets.add_generator","text":"add_generator(nw_data::Dict, bus_index::Int) -> String\n\nAdds generator at bus with index bus_index in grid data (nw_data), and returns dictionary key for the new generator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Any, Any, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.build_market(\n    ::Type{PowerModelsMarket},\n    network_data,\n    strategic_generators,\n    solver;\n    market_formulation=DCPPowerModel,\n    opf_builder=PowerModels.build_opf,\n    assert_consistency=true,\n)\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\nassert_consistency=true: Boolean to force check if strategic generators indexes (in strategic_generators) reference generators located at the specified bus_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.build_market(\n    market::Type{PowerModelsMarket},\n    network_data::Dict,\n    gen_indexes::AbstractVector{String},\n    bus_indexes::AbstractVector{String},\n    solver;\n    market_formulation=DCPPowerModel,\n    opf_builder=PowerModels.build_opf,\n    kwards...,\n)\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nbus_indexes::AbstractVector{String}: Vector of strategic generators' bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.build_market(\n    market::Type{PowerModelsMarket},\n    network_data::Dict,\n    gen_indexes::AbstractVector{String},\n    solver;\n    market_formulation=DCPPowerModel,\n    opf_builder=PowerModels.build_opf,\n)\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{OptimalBids.PowerModelsMarkets.PowerModelsMarket}","page":"API","title":"OptimalBids.clear_market!","text":"OptimalBids.clear_market!(market::PowerModelsMarket)\n\nClears market and stores result's dictionary in result.\n\n\n\n\n\n","category":"method"},{"location":"examples/Nonconvex/#Profit-Maximization-Example:-using-Nonconvex.jl","page":"Examples","title":"Profit Maximization Example: using Nonconvex.jl","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Examples","title":"Examples","text":"This a example on how to use Nonconvex.jl to maximize the profit of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/Nonconvex/","page":"Examples","title":"Examples","text":"For this example, we will use a market of type PowerModelsMarkets. ","category":"page"},{"location":"examples/Nonconvex/","page":"Examples","title":"Examples","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\n\nusing Nonconvex\nusing NonconvexIpopt # Nonconvex.@load Ipopt\nusing NonconvexBayesian # Nonconvex.@load BayesOpt\n\nusing Plots # For some evaluation plots at the end\n\n#=\nCASE DEFINITION\n=#\n\n# Read market data from IEEE 118 bus case\ncase_name = \"case118.m\"\nDATA_DIR = joinpath(dirname(dirname(dirname(@__DIR__))), \"test/data\")\ncase_file_path = joinpath(DATA_DIR, case_name)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Let's make the case a bit more interesting, by adding some randomness to existing generators costs and available load.\nusing Random\nRandom.seed!(654654)\nfor gen in values(network_data[\"gen\"])\n    gen[\"cost\"][end-1] += rand(-2000.0:2500.0)\nend\nload_mul_factor = 6.8\nfor load in collect(values(network_data[\"load\"]))[1:20:end]\n    load[\"pd\"] *= load_mul_factor * rand(0.01:0.01:3)\nend\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n\n#=\nOptimalBids API\n=#\n\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    Clp.Optimizer,\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed bidding time.\noffer_weights = rand(num_strategic_buses)\noffer_weights = offer_weights/ sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 65.0\nrange_mul_factor = min_total_volume:0.1:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\n\n# Let's plot and see how the range profit evaluatiuon went:\nplt_range = plot(collect(range_mul_factor), p_curve,\n    title=\"Case $case_name\",\n    label=\"Range Evaluation - Random Offers\",\n    ylabel=\"Profit (\\$)\",\n    xlabel=\"Multiplicative Factor\",\n    legend=:outertopright,\n)\n\n#=\nNonconvex API\n=#\n\n# Nonconvex needs a minimization objective function that only receives the decision vector.\nfunction profit_function(total_volume)\n    return - profit_for_bid!(market, offer_weights .* total_volume[1])\nend\n\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\n\n# Build Nonconvex optimization model:\nmodel = Model()\nset_objective!(model, profit_function, flags = [:expensive])\naddvar!(model, [min_total_volume], [max_total_volume])\nadd_ineq_constraint!(model, x -> -1) # errors when no inequality is added! \n\n# Solution Method: Bayesian Optimization\nalg = BayesOptAlg(IpoptAlg())\noptions = BayesOptOptions(\n    sub_options = IpoptOptions(max_iter = maxiter),\n    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5,\n)\n\n# Optimize model:\nr = optimize(model, alg, [min_total_volume], options = options)\n\nbest_solution = r.minimizer\nbest_profit = -r.minimum\nr.niters # number of iterations of the \n\nscatter!(plt_range, [best_solution; r.sub_result.minimizer], [best_profit; -r.sub_result.minimum],\n    label=\"BayesOpt Offer - OPF Calls:$(r.sub_result.fcalls)\",\n    size=(1000, 1000)\n)\n\nplot!(range_mul_factor, -getproperty.(r.surrogates[1].(range_mul_factor), :lo),\n    label=\"BayesOpt - Surrogate Function\",\n)","category":"page"},{"location":"examples/Nonconvex/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBids","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#99DDFF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/andrewrosemberg/OptimalBids.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star andrewrosemberg/OptimalBids.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#OptimalBids","page":"Home","title":"OptimalBids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OptimalBids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple Package to help evaluate bids in markets/auctions.","category":"page"},{"location":"#Instalation","page":"Home","title":"Instalation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/andrewrosemberg/OptimalBids.jl","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The framework used is based around the dispatch of the following functions for specified markets (subtypes of the core abstract type Market): build_market, change_bids!, clear_market!, calculate_profit (see docstrings for more info - e.g. @doc change_bids!). I.e. these are the functions that need to be implemented for each market type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the functions profit_for_bid!, profit_curve! are implemented in a reasonably generic way, allowing users to dispatch them with any new market. (see docstrings for more info - e.g. @doc profit_for_bid!).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
