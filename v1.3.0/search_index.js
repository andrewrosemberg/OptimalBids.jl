var documenterSearchIndex = {"docs":
[{"location":"api/#Api","page":"API","title":"Api","text":"","category":"section"},{"location":"api/#OptimalBids","page":"API","title":"OptimalBids","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids]","category":"page"},{"location":"api/#OptimalBids.Market","page":"API","title":"OptimalBids.Market","text":"Market\n\nMutable Structure of a market instance.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.build_market-Union{Tuple{M}, Tuple{Type{M}, Vararg{Any}}} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.build_market","text":"build_market(::Type{Market}, params...) -> Market\n\nBuilds market of type Market using provided parameters (params).\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.calculate_profit-Tuple{M} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.calculate_profit","text":"calculate_profit(market::Market) -> NamedTuple{(:cleared_volumes, :clearing_prices, :profit), Tuple{Vector{Int}, Vector{Int}, Vector{Int}}}\n\nRetrieves strategic agent's cleared volumes and prices from the market and calculates per bid profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.change_bids!-Union{Tuple{M}, Tuple{M, Vector}} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.change_bids!","text":"change_bids!(market::Market, new_bids::Vector)\n\nChanges strategic agent's bids in the market to new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{M} where M<:OptimalBids.Market","page":"API","title":"OptimalBids.clear_market!","text":"clear_market!(market::Market)\n\nClears the market.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_curve!-Tuple{OptimalBids.Market, Vector{<:AbstractVector}}","page":"API","title":"OptimalBids.profit_curve!","text":"profit_curve!(market::Market, range_new_bids::Vector{Vector{Any}}) -> Vector{Float64}\n\nConstructs profit curve for bids provided in range_new_bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.profit_for_bid!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.profit_for_bid!","text":"profit_for_bid!(market::Market, new_bids::Vector{Any}) -> Float64\n\nCalculates overall profit when market is cleared with new_bids. This function will sequentiall call change_bids!, clear_market! and calculate_profit.\n\n\n\n\n\n","category":"method"},{"location":"api/#PowerModelsMarkets","page":"API","title":"PowerModelsMarkets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OptimalBids.PowerModelsMarkets]\nPrivate = false","category":"page"},{"location":"api/#OptimalBids.PowerModelsMarkets","page":"API","title":"OptimalBids.PowerModelsMarkets","text":"PowerModelsMarkets\n\nSubModule that implements interfact with PowerModels.jl\n\n\n\n\n\n","category":"module"},{"location":"api/#OptimalBids.PowerModelsMarkets.PowerModelsMarket","page":"API","title":"OptimalBids.PowerModelsMarkets.PowerModelsMarket","text":"PowerModelsMarket <: OptimalBids.Market\n\nEnergy-Market type that uses PowerModels' OPF to clear the auction.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.PowerModelsMarkets.add_generator-Tuple{Dict, Int64}","page":"API","title":"OptimalBids.PowerModelsMarkets.add_generator","text":"add_generator(nw_data::Dict, bus_index::Int) -> String\n\nAdds generator at bus with index bus_index in grid data (nw_data), and returns dictionary key for the new generator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.PowerModelsMarkets.profit_and_gradient_for_bid!-Tuple{OptimalBids.Market, Vector}","page":"API","title":"OptimalBids.PowerModelsMarkets.profit_and_gradient_for_bid!","text":"profit_and_gradient_for_bid!(market::Market, new_bids::Vector{Any}) -> Float64, Float64\n\nCalculates overall profit when market is cleared with new_bids and its gradient w.r.t the vector of bids.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Any, Any, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     ::Type{PowerModelsMarket},     networkdata,     strategicgenerators,     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.buildopf,     assert_consistency=true, )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\nstrategic_generators::Vector{NamedTuple{(:gen_index, :bus_index),Tuple{String,String}}}: Vector of strategic generators' indexes and their bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\nassert_consistency=true: Boolean to force check if strategic generators indexes (in strategic_generators) reference generators located at the specified bus_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     market::Type{PowerModelsMarket},     networkdata::Dict,     genindexes::AbstractVector{String},     busindexes::AbstractVector{String},     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.build_opf,     kwards..., )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nbus_indexes::AbstractVector{String}: Vector of strategic generators' bus indexes. \nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.build_market-Tuple{Type{OptimalBids.PowerModelsMarkets.PowerModelsMarket}, Dict, AbstractVector{String}, Any}","page":"API","title":"OptimalBids.build_market","text":"OptimalBids.buildmarket(     market::Type{PowerModelsMarket},     networkdata::Dict,     genindexes::AbstractVector{String},     solver;     marketformulation=DCPPowerModel,     opfbuilder=PowerModels.buildopf, )\n\nCreates Energy-Market of type PowerModelsMarket.\n\nArguments:\n\nnetwork_data::Dict: PowerModels data structure.\ngen_indexes::AbstractVector{String}: Vector of strategic generators' indexes.\nresult::Union{Dict,Missing}: Market clearing result.\nmarket_formulation: Network formulation used in the PowerModels' auction clearing process (i.e. OPF).\nopf_builder: PowerModels opf builder.\nsolver: JuMP optimization solver that should be able to solve the OPF created based on the passed market_formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#OptimalBids.clear_market!-Tuple{OptimalBids.PowerModelsMarkets.PowerModelsMarket}","page":"API","title":"OptimalBids.clear_market!","text":"OptimalBids.clear_market!(market::PowerModelsMarket)\n\nClears market and stores result's dictionary in result.\n\n\n\n\n\n","category":"method"},{"location":"examples/Nonconvex/#Examples","page":"Nonconvex.jl","title":"Examples","text":"","category":"section"},{"location":"examples/Nonconvex/#Profit-Maximization-Example:-using-Nonconvex.jl","page":"Nonconvex.jl","title":"Profit Maximization Example: using Nonconvex.jl","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"This a example on how to use Nonconvex.jl to maximize the profit of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"For this example, we will use a market of type PowerModelsMarkets which represents an energy spot market.\nCase instance is IEEE 118 Bus Case\nTo ilustrate a situation where the company defines the distribution of volume across it's assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.  ","category":"page"},{"location":"examples/Nonconvex/#Include-Needed-Packages","page":"Nonconvex.jl","title":"Include Needed Packages","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\nusing JuMP: optimizer_with_attributes\n\nusing Nonconvex\nusing NonconvexIpopt # Nonconvex.@load Ipopt\nusing NonconvexBayesian # Nonconvex.@load BayesOpt\n\nusing Plots # For some evaluation plots at the end\n","category":"page"},{"location":"examples/Nonconvex/#Case-Definition","page":"Nonconvex.jl","title":"Case Definition","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Read market data from IEEE 118 bus case\ncase_name = \"case118.m\"\nDATA_DIR = joinpath(dirname(dirname(dirname(@__DIR__))), \"test/data\")\ncase_file_path = joinpath(DATA_DIR, case_name)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Let's make the case a bit more interesting, by adding some randomness to existing generators costs and available load.\nusing Random\nRandom.seed!(654654)\nfor gen in values(network_data[\"gen\"])\n    gen[\"cost\"][end-1] += rand(-2000.0:2500.0)\nend\nload_mul_factor = 6.8\nfor load in collect(values(network_data[\"load\"]))[1:20:end]\n    load[\"pd\"] *= load_mul_factor * rand(0.01:0.01:3)\nend\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n","category":"page"},{"location":"examples/Nonconvex/#OptimalBids-API","page":"Nonconvex.jl","title":"OptimalBids API","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    optimizer_with_attributes(Clp.Optimizer, \"LogLevel\" => 0),\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.\noffer_weights = rand(num_strategic_buses)\noffer_weights = offer_weights/ sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 65.0\nrange_mul_factor = min_total_volume:0.1:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\n\n# Let's plot and see how the range profit evaluatiuon went:\nplt_range = plot(collect(range_mul_factor), p_curve,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (\\$)\",\n    xlabel=\"Multiplicative Factor\",\n    legend=:outertopright,\n);\nplt_comp = deepcopy(plt_range);","category":"page"},{"location":"examples/Nonconvex/#Nonconvex-API","page":"Nonconvex.jl","title":"Nonconvex API","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Nonconvex needs a minimization objective function that only receives the decision vector.\nfunction profit_function(total_volume)\n    global fcalls += 1\n    return - profit_for_bid!(market, offer_weights .* total_volume[1])\nend\n","category":"page"},{"location":"examples/Nonconvex/#BayesOpt-(0-Order)","page":"Nonconvex.jl","title":"BayesOpt (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\n# ps.: Currently, no option for limiting fcalls.\nmaxiter = 10\nglobal fcalls = 0\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, profit_function, flags = [:expensive])\naddvar!(model, [min_total_volume], [max_total_volume])\nadd_ineq_constraint!(model, x -> -1) # errors when no inequality is added!\n\n# Solution Method: Bayesian Optimization\nalg = BayesOptAlg(IpoptAlg())\noptions = BayesOptOptions(\n    sub_options = IpoptOptions(max_iter = maxiter),\n    maxiter = maxiter, ftol = 1e-4, ctol = 1e-5, initialize=false,\n)\n\n# Optimize model:\nr_bayes = optimize(model, alg, [min_total_volume]; options = options)\n\nbest_solution = r_bayes.minimizer\nbest_profit = -r_bayes.minimum\n\nscatter!(plt_comp, [best_solution; r_bayes.sub_result.minimizer], [best_profit; -r_bayes.sub_result.minimum],\n    label=\"BayesOpt - OPF Calls:$(fcalls)\",\n)\n\nplt_surrogate = deepcopy(plt_range)\n\nplot!(plt_surrogate, range_mul_factor, -getproperty.(r_bayes.surrogates[1].(range_mul_factor), :lo),\n    title=\"BayesOpt Analysis\",\n    label=\"Surrogate Function\",\n)","category":"page"},{"location":"examples/Nonconvex/#NLopt-BOBYQA-(0-Order)","page":"Nonconvex.jl","title":"NLopt - BOBYQA (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexNLopt\n\nmaxeval = 4\nglobal fcalls = 0\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Sequential Least-Squares Quadratic Programming\nmethod = :LN_BOBYQA\nalg = NLoptAlg(:LN_BOBYQA)\noptions = NLoptOptions(maxeval=maxeval)\n\n# Optimize model\nr = optimize(model, alg, [min_total_volume], options = options)\n\nbest_solution = r.minimizer\nbest_profit = -r.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"NLOpt-$(method) - OPF Calls:$(fcalls)\",\n);\n\nprintln(\"OPF Evaluations: \", fcalls)","category":"page"},{"location":"examples/Nonconvex/#NonconvexMultistart-GPSampler-(0-Order)","page":"Nonconvex.jl","title":"NonconvexMultistart - GPSampler (0-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexMultistart\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Hyperopt\nglobal fcalls = 0\nmaxiter = 4\nmethod = :Hyperopt\nalg = HyperoptAlg(IpoptAlg())\noptions = HyperoptOptions(\n    sub_options = IpoptOptions(max_iter = maxiter), sampler = GPSampler(),\n    iters = 2,\n    keep_all=true\n)\n\n# Optimize model\nr_hyp = optimize(model, alg, [min_total_volume], options = options)\n\nbest_solution = r_hyp.minimizer\nbest_profit = -r_hyp.minimum\n\nscatter!(plt_comp, best_solution, [best_profit],\n    label=\"$(method) Offer - OPF Calls:$(fcalls)\",\n);\n\nplt_visited = deepcopy(plt_range)\n\nscatter!(plt_visited, [i.minimizer[1] for i in r_hyp.results], [- i.minimum for i in r_hyp.results],\n    label=\"$(method) Offer - OPF Calls:$(fcalls)\",\n    title=\"Hyperopt Visited Offers\",\n)","category":"page"},{"location":"examples/Nonconvex/#Profit-Comparison-NLP-0-Order-Strategies","page":"Nonconvex.jl","title":"Profit Comparison NLP 0-Order Strategies","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nplot(plt_comp, margin=5Plots.mm,\n    title=\"Profit Comparison NLP Strategies\",\n)","category":"page"},{"location":"examples/Nonconvex/#NLopt-CCSAQ-(1-Order)","page":"Nonconvex.jl","title":"NLopt - CCSAQ (1-Order)","text":"","category":"section"},{"location":"examples/Nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"\nusing NonconvexNLopt\n\nmaxeval = 4\nglobal fcalls = 0\n\n# Build Nonconvex optimization model:\nmodel = Nonconvex.Model()\nset_objective!(model, profit_function)\naddvar!(model, [min_total_volume], [max_total_volume])\n\n# Solution Method: Sequential Least-Squares Quadratic Programming\nmethod = :LD_CCSAQ\nalg = NLoptAlg(method)\noptions = NLoptOptions(maxeval=maxeval)\n\n# Optimize model\nr = optimize(model, alg, [min_total_volume], options = options)\n\nbest_solution = r.minimizer\nbest_profit = -r.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"NLOpt-$(method) - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"examples/Optim/#Examples","page":"Optim.jl","title":"Examples","text":"","category":"section"},{"location":"examples/Optim/#Profit-Maximization-Example:-using-Optim.jl","page":"Optim.jl","title":"Profit Maximization Example: using Optim.jl","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"This a example on how to use Optim.jl to maximize the profit of a company operating in a defined market (through the OptimalBids API).","category":"page"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"For this example, we will use a market of type PowerModelsMarkets which represents an energy spot market.\nCase instance is IEEE 118 Bus Case\nTo ilustrate a situation where the company defines the distribution of volume across it's assets in a predefined way (and reduce the decision dimentionality), the only controlable variable to maximize the company profit is a multiplicative factor of all offers.  ","category":"page"},{"location":"examples/Optim/#Include-Needed-Packages","page":"Optim.jl","title":"Include Needed Packages","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"using OptimalBids\nusing OptimalBids.PowerModelsMarkets\nusing Clp # Market Clearing Solver\nusing JuMP: optimizer_with_attributes\n\nusing Optim\n\nusing Plots # For some evaluation plots at the end\n","category":"page"},{"location":"examples/Optim/#Case-Definition","page":"Optim.jl","title":"Case Definition","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Read market data from IEEE 118 bus case\ncase_name = \"case118.m\"\nDATA_DIR = joinpath(dirname(dirname(dirname(@__DIR__))), \"test/data\")\ncase_file_path = joinpath(DATA_DIR, case_name)\nnetwork_data = PowerModels.parse_file(case_file_path)\n\n# Let's make the case a bit more interesting, by adding some randomness to existing generators costs and available load.\nusing Random\nRandom.seed!(654654)\nfor gen in values(network_data[\"gen\"])\n    gen[\"cost\"][end-1] += rand(-2000.0:2500.0)\nend\nload_mul_factor = 6.8\nfor load in collect(values(network_data[\"load\"]))[1:20:end]\n    load[\"pd\"] *= load_mul_factor * rand(0.01:0.01:3)\nend\n\n# Pretend we are a company constructing a new set of generators in the grid.\n# Choose a percentage of the total number of buses to install the new generators:\npercentage_buses = 0.09\n\n# We need the keys PowerModels uses to reference the appropriate buses in it's network data dictionary.\n# First, find out all available keys:\nbus_indexes = collect(keys(network_data[\"bus\"]))\n# Then, calculate number of buses that consitute the chose percent (`percentage_buses`):\nnum_buses = length(bus_indexes)\nnum_strategic_buses = ceil(Int, percentage_buses * num_buses)\n# To avoid any biases let's grab some generators in the middle:\nbus_indexes = bus_indexes[21:(21 + num_strategic_buses - 1)]\n# Finally, add new generators to the network grid data and collect their reference keys.\ngenerator_indexes = [\n    add_generator(network_data, parse(Int, bus_idx)) for bus_idx in bus_indexes\n]\n","category":"page"},{"location":"examples/Optim/#OptimalBids-API","page":"Optim.jl","title":"OptimalBids API","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Define market\nmarket = build_market(\n    PowerModelsMarket,\n    network_data,\n    generator_indexes,\n    optimizer_with_attributes(Clp.Optimizer, \"LogLevel\" => 0),\n)\n\n# Relative distribution of offers are sometimes predefined and cannot be changed at bidding time.\noffer_weights = rand(num_strategic_buses)\noffer_weights = offer_weights/ sum(offer_weights)\n\n# However, the decision maker is allowed to increase all bids evenly:\nmin_total_volume = 0.0\nmax_total_volume = 65.0\nrange_mul_factor = min_total_volume:0.1:max_total_volume\nbid_range = [offer_weights .* [i] for i in range_mul_factor]\np_curve = profit_curve!(market, bid_range)\n\n# Let's plot and see how the range profit evaluatiuon went:\nplt_range = plot(collect(range_mul_factor), p_curve,\n    label=\"Range Evaluation\",\n    ylabel=\"Profit (\\$)\",\n    xlabel=\"Multiplicative Factor\",\n    legend=:outertopright,\n);\nplt_comp = deepcopy(plt_range);","category":"page"},{"location":"examples/Optim/#Profit-Function","page":"Optim.jl","title":"Profit Function","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Optim needs a minimization objective function that only receives the decision vector.\nfunction profit_function(total_volume)\n    global fcalls += 1\n    return - profit_for_bid!(market, offer_weights .* total_volume[1])\nend\n","category":"page"},{"location":"examples/Optim/#NelderMead-(0-Order)","page":"Optim.jl","title":"NelderMead (0-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\n# Solve Optim optimization model:\nlower = [min_total_volume]\nupper = [max_total_volume]\ninitial_x = [min_total_volume] .+ 0.001 # Initial value cannot be on boundary value\n\n# Limiting fcalls.\nfunction advanced_fcall_control(x)\n    println(\" * Fcalls so far:     \", fcalls)\n    if fcalls >= maxiter\n        return true\n    end\n    println()\n    false\nend\n\ninner_optimizer = NelderMead()\nresults = Optim.optimize(profit_function, lower, upper, initial_x, Fminbox(inner_optimizer), Optim.Options(f_calls_limit=maxiter, callback = advanced_fcall_control, store_trace=true))\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"NelderMead - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"examples/Optim/#LBFGS-(1-Order)","page":"Optim.jl","title":"LBFGS (1-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Profit and gradient\nusing LinearAlgebra\n\nfunction fg!(F,G,total_volume)\n    y, Δ = profit_and_gradient_for_bid!(market, offer_weights .* total_volume[1])\n    global fcalls += 1\n\n    isnothing(G) || copyto!(G, dot(Δ, offer_weights))\n    isnothing(F) || return y\n\n    nothing\nend\n\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\ninner_optimizer = LBFGS()\nresults = Optim.optimize(Optim.only_fg!(fg!), lower, upper, initial_x, Fminbox(inner_optimizer), Optim.Options(f_calls_limit=maxiter, callback = advanced_fcall_control, store_trace=true))\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"LBFGS - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"examples/Optim/#Brent-(0-Order)","page":"Optim.jl","title":"Brent (0-Order)","text":"","category":"section"},{"location":"examples/Optim/","page":"Optim.jl","title":"Optim.jl","text":"\n# Max Number of Iterations for the solution method (proxy to a time limit at bidding time).\nmaxiter = 10\nglobal fcalls = 0\n\nfunction profit_function(total_volume)\n    global fcalls += 1\n    return - profit_for_bid!(market, offer_weights .* total_volume)\nend\nresults = Optim.optimize(profit_function, min_total_volume, max_total_volume, Brent(); callback = advanced_fcall_control, store_trace=true)\n\nbest_solution = results.minimizer\nbest_profit = -results.minimum\n\nscatter!(plt_comp, [best_solution], [best_profit],\n    label=\"Brent - OPF Calls:$(fcalls)\",\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBids","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#99DDFF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/andrewrosemberg/OptimalBids.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star andrewrosemberg/OptimalBids.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#OptimalBids","page":"Home","title":"OptimalBids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OptimalBids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple Package to help evaluate bids in markets/auctions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/andrewrosemberg/OptimalBids.jl","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The framework used is based around the dispatch of the following functions for specified markets (subtypes of the core abstract type Market): build_market, change_bids!, clear_market!, calculate_profit (see docstrings for more info - e.g. @doc change_bids!). I.e. these are the functions that need to be implemented for each market type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the functions profit_for_bid!, profit_curve! are implemented in a reasonably generic way, allowing users to dispatch them with any new market. (see docstrings for more info - e.g. @doc profit_for_bid!).","category":"page"}]
}
